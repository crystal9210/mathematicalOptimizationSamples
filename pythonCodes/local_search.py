# 局所探索法を用いて与えられた関数の最小値を探索するプログラム
# 局所探索法の基本ステップ
# 局所探索法は以下のステップで進行する。
# 初期解を決定: 適当な初期解を設定
# 近傍の探索: 現在の解の近くにある解（近傍）を生成
# 改善解の確認: 近傍の中から、現在の解よりも良い解（目的関数の値が小さい解）があるか確認
# 解の更新: 改善解が見つかればそれを新しい解として設定し、2のステップに戻る、改善解が見つからなければ終了する。

# ーーポイントーー
# 今回は最小の値を求めるので、特定の地点を初期値としたときのその点からの近傍をステップバイステップで考慮していき、
# その範囲で最良のものを選択していく、最良移動戦略をとっているため、線形に移動する可能性が高い

# 局所探索法とは：適当な初期解から出発し、解の近傍にそれより良い解があれば置き換える、という操作を繰り返し実行して、解の更新が行われなくなった時終了する
# ー＞TODO:ここで、「解の更新が行われなくなった」の判断基準としてはどのような指標を置くのか

# 近傍回の妥当性ー＞「良い解同士は似た構造を持つ」；近傍回最適性(proximity optimality principle,POP)
# 挿入近傍、交換近傍、即時移動戦略、最良移動戦略
import numpy as np
import matplotlib.pyplot as plt
from typing import List # 型ヒントのためのライブラリ、リストの中に何が含まれているかを明示するために使用

# 引数にfloat値を受け取りそれに対する一定の他公式の数値計算の結果を計算・返す関数
def f(x: float) -> float:
    x = np.clip(x, -3.3, 3.3) # np.clip:xを第2引数と第3引数の間の範囲に収める
    # xを使って多項式を計算し、結果として返す
    return (44 * x**6 +13 * x**5 - 638 * x**4 -88 * x**3 +2600 * x**2 -261 * x + 6.5653624787847)

# 可視化関数
# hists:探索履歴のリスト、draw_arrow:履歴間の遷移を矢印で書くかどうかのフラグ
def vis(hists: List[List[float]], draw_arrow: bool = False) -> None:
    xs = np.linspace(-3.3, 3.3, 100) # linspace:-3.3から3.3まで等間隔で100個の点を生成する関数
    ys=f(xs) # 生成した点に対して目的関数fを適用して、その数値を計算、取得
    fig = plt.figure(figsize=(12, 5)) # 図の作成、figsize:図のサイズを指定
    # サブプロット関数の挙動の確認ファイルー＞同一ディレクトリのsabplot.pyファイルを実行して確認
    ax = fig.add_subplot(111) # サブプロットの作成；111は1行1列の1番目のプロットを意味
    ax.plot(xs, ys)
    ax.set_title("f(x) (-3.3 <= x <= 3.3)")
    ax.set_xlabel("x")
    ax.set_ylabel("f(x)")
    ax.set_xticks(np.linspace(-3.3, 3.3, 5)) # -3.3から3.3の範囲で等間隔に5つの点を生成するー＞今回：[-3.3, -1.65, 0, 1.65, 3.3]ー＞X軸のメモリとして表示
    ax.grid() # グリッド線の表示
    # 探索履歴ごとにループ
    # 例：histsが[[x1, x2, ...], [y1, y2, ...]]ー＞最初のループはhistが[x1, x2, ...]、次のループは[y1, y2, ...]となる
    for hist in hists:
        # TODO:下のrangeの第三引数の値を変えて観察する、1-5の整数とかが良いかも。
        for i in range(1, len(hist)-1, 5): # 1からlen(hist)-1までの範囲でステップ幅を5としてインデックスを生成；例：hist:20ー＞1,6,11,16のインデックスを生成、ループー＞全てのポイントをプロットせず、5ステップごとに間引くことでプロットが過密にならず見やすくなる
            ax.plot(hist[i], f(hist[i]), 'o', color= "gray") # 灰色のマーカで間引いた各点をプロット
        ax.plot(hist[0], f(hist[0]), 'o', color="blue")
        ax.plot(hist[-1], f(hist[-1]), 'o', color="red") # hist[-1]:探索の最終点
    if draw_arrow:
        for hist in hists:
            for j in range(len(hist) - 1):
                ax.annotate("",
                            xy=(hist[j + 1], f(hist[j + 1])),
                            xytext=(hist[j], f(hist[j])),
                            arrowprops=dict(arrowstyle="->", color="green"))

    plt.show()

# 局所探索方の関数実装 | x0:初期解
def local_search(x0: float) -> List[float]:
    x0 = np.clip(x0, -3.3, 3.3) # とりあえず初期解の範囲を限定ー＞TODO:この範囲指定は今回どういう感じの意図があってしているのか
    x = x0
    k = 0 # 探索回数初期化
    best_score = f(x) # 初期解の目的間数値を計算して代入
    hist = [x] # 初期解を探索履歴に追加

    while k < 100:
        k += 1
        Nx = np.linspace(x-0.05, x+0.05, 10) # 近傍を生成
        fNx = f(Nx) # 近傍の各点の目的間数値を計算
        # コードベース下のコメントアウトに方針としての違いやメリットデメリットについてまとめる
        if np.any(fNx < best_score): # np.any:近傍に現在の解よりも良い解があるか確認ー＞与えられた配列内で少なくとも一つの要素が指定された条件を満たすかどうかを判定
            # new_x = np.random.choice(Nx[np.where(fNx < best_score)[0]]) # ランダムに選ぶことで、局所最適解に留まらずより多くの探索空有かんを探索することができるー＞より良い解を見つける可能性が高まる
            new_x = Nx[np.argmin(fNx)] # 最良の解を選択、今回は最小値を求めるためこのような選択が最良移動戦略に相当
            best_score = f(new_x)
            x = new_x
            hist.append(new_x)
        else:
            # 改善解が無い場合、探索を終了
            break

    assert(len(hist) == k)
    print(f"探索回数: {len(hist)}回")
    print(f"得られた最適値: {f(hist[-1])}")
    print("真の最適値: 0")
    return hist


# 実行ルーチン | x0が-2のとき、-1.63の時で、結果が異なる、また、選択アルゴリズムーl:74のランダム優性解選択をすると結果が毎回微妙に異なる、最良移動戦略(l:75)を取っても真の最適解とは誤差があるが、結果は一定の値が取得できる(これは近傍の値を取るときに離散的な数値を取ることによる)
hist =local_search(x0=-1.63) #x0の初期値を変えて遷移がどうなるのかを観察するー＞局所探索法の性質の理解
vis([hist],draw_arrow=True)

# ランダム選択をする際の戦略
# 近傍の幅が小さいと今回のようにあまり有効な結果が得られなくなるー＞遷移先が一定になるため。
# ー＞幅を持たせることが重要。また、探索対象の連続的な数値遷移の傾向に大きく性能が依存
# 最良移動選択に比較して不安定(結果が毎回異なる)ー＞各実行の結果を記録し、平均値、標準偏差、最良値、最悪値を計算
# 使用目的：アルゴリズムの安定性と性能を評価する、パラメータの調整に対するアルゴリズムの感度を確認する
# 最適化の要素ー＞ランダム選択の範囲、回数、探索のステップサイズ、アルゴリズムのパラメータの調整により性能を最適化
# ー＞アルゴリズムの収束速度の向上、最適解の質を向上

# 参考：探索範囲が狭く、局所最適解がほとんど存在しない場合、ランダム選択と最良移動戦略の結果はほぼ一致する、しかし、探索範囲が広がり、複数の局所最適解が存在する場合、
# ランダム選択は、その経路の不安定さから、異なる経路を探索し、全体最適解を見つける可能性が高まる

# 最良移動戦略が有効な場合ー＞求めるシステムの対象の数値がシンプルな場合、より早く最適解またはその近似解を求められる

# 【ランダム選択と最良選択の比較】
# ランダム選択：平均値が比較的高い、標準偏差が大きい、最良値と最悪値の幅が広い
# 最良選択：平均値が低い、標準偏差が小さい、最良値と最悪値の幅が狭い